\chapter{Introduction}
\label{chapter:introduction}


The developments in mathematical computing have facilitated the solutions of analyses of \textit{forward problems}. A forward problem involves application of given inputs (or parameters) to the physical model of a system. These inputs could include initial and/or boundary conditions, geometry, material/system properties, etc. The mathematical relation between these known quantities and the quantity of interest, which is often called the forward map, is then solved to obtain the physical state of the system. The ready availability of computational resources and efficient algorithms have made these forward problems extremely scalable. Furthermore, the recent progress made in data accumulation and analysis has generated commensurate interest in extracting information about the physical model from the observed data. Significant research has already been conducted on the inference of physical models from the observed data \cite{banks2012estimation, sullivan2015introduction}; however, the solution of inverse problems presents a different set of challenges.

Inverse problems involve inference of inputs (commonly known as parameters) from noisy observations of a particular physical model (data). However, inverse problems are known to be \textit{ill-posed}. For a map $\mathcal{F} : \mathcal{X} \rightarrow \mathcal{Y}$, the relation $\mathcal{F}(m) + \eta = d$, where the parameter $m \in \mathcal{X}$, data $d \in \mathcal{Y}$, and noise $\eta$, the inverse problem may be ill-posed due to violation of one of the three conditions for well-posedness postulated by Hadamard \cite{hadamard1923lectures}. Despite the large-scale nature of the data, it does not provide sufficient information to compute a unique solution for the parameter. However, more often than not, the \textit{Stability} condition is violated due to the discontinuous dependence of the parameter \textit{m} on the data \textit{d}. This can be attributed to the presence of noise $\eta$, which is impossible to eliminate. A computational framework capable of solving such inverse problems, thus, became an important requirement.

This requirement was addressed by \texttt{hIPPYlib}, an inverse problem library that was capable of solving ill-posed large-scale deterministic and Bayesian inverse problems \cite{villa2018hippylib}. \texttt{hIPPYlib} discretized the forward map (which is one of the three components of an inverse problem, as discussed later) by using the functionality of the \texttt{FEniCS} library---a finite element library for partial differential equations (PDEs) \cite{alnaes2015fenics}. Since the data structures used in the FEniCS library are wrappers on the PETSc library's data structures, \texttt{hIPPYlib} uses PETSC \cite{balay2001petsc} for its linear solvers and algebra operations. The \texttt{FEniCS} library contains different components with multiple layers of abstraction for ease of development and usage. However, given the mathematically complex nature of finite element problems, the consistent development of the FEniCS library and subsequently, that of \texttt{hIPPYlib}, requires individuals highly skilled in programming and FEM concepts.

Similar to The FEniCS Project's DOLFIN library \cite{alnaes2015fenics, logg2010dolfin}, Firedrake \cite{rathgeber2016firedrake} is a library that provides automated solutions of partial differential equations (PDEs) using the finite element method (FEM). Firedrake managed to address the abovementioned challenges by adopting a philosophy that emphasized on the separation of concerns. Since a multidisciplinary skillset, which ranges from mathematical expertise in numerical analyses to a deep understanding of parallel computation, is required for the development of these tools, it became more practical to develop abstract layers in the library that catered to a particular skillset. Firedrake introduced a new layer of abstraction named PyOP2 \cite{rathgeber2012pyop2} that clearly formed a distinction between the finite element interface and the parallel execution of its algorithm over the mesh. PyOP2 thus creates a separation between the discretization of the mathematical operators and their parallel execution over the mesh. This has made the Firedrake codebase significantly more compact. Furthermore, Rathgeber et al. \cite{rathgeber2016firedrake} also reported a performance improvement over FEniCS.

Thus, the need for an inverse problem library built on a modularized FEM solver like Firedrake led to the conception of \texttt{hIPPYfire}. This study presents the structure and implementation of \texttt{hIPPYfire}---an inverse problem library modelled similar to \texttt{hIPPYlib}, but built on Firedrake. The algorithms implemented in \texttt{hIPPYfire} are identical to those implemented in \texttt{hIPPYlib}. However, there are minor differences in the utilities and linear algebra functions due to the currently limited functionality of the Firedrake library---all of which have been elaborated and expanded upon in the following sections of this report.

Section \ref{chapter: inverse-problems} provides a brief introduction to the theory behind inverse problems. The advantages of the Firedrake library over FEniCS are explained with some technical context in Section \ref{chapter: software}. Emphasis is also placed on the shortcomings of the Firedrake library and the development of custom linear algebra methods to address them. The structure of \texttt{hIPPYfire} is also discussed in Section \ref{chapter: software}. The \texttt{hIPPYfire} library is validated in Section \ref{chapter:sample-problem} by creating a test case involving a Bayesian inverse problem. This section is followed by the conclusion (Section \ref{chapter:conclusion}), which discusses the development roadmap for \texttt{hIPPYfire}.