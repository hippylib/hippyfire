\chapter{Intrduction}
\label{chapter:introduction}

The advances made in the fields of high-performance computing have facilitated the development of large-scale solvers for \textit{forward problems}. In a forward problem, inputs (such as the initial and boundary conditions, geometry, sources, material properties etc.) are supplied to the model of a physical system. The forward problem is then solved to determine the output quantities that are of interest. The ready availability of computational resources and the development of powerful discretization techniques that cater to a large variety of models have made the solutions of these forward problems extremely scalable. The vast amounts of data that are available, along with the subsequent improvements in data analysis techniques, have generated commensurate interest in extracting information about the physical model from the observed data. While this progress has been driven by machine learning algorithms, the estimation of physics-based models from data has been a crucial aspect of applied mathematics. Although significant research has already been conducted in this field \cite{banks2012estimation, sullivan2015introduction}, the solution of inverse problems presents a different set of challenges.

Most PDE models of physical systems are characterized by a low-dimensional solution manifold. The inputs to these physical systems include initial and boundary conditions, geometry, sources, material and system properties, etc. The outputs, which are functions of some state variables, are obtained by solving the governing PDEs of the system. The low dimensionality of the map is attributed to the fact that the inputs and outputs are infinite-dimensional (or high-dimensional after discretization). The map from the inputs to the outputs must thus be smoothing, otherwise it may result in information loss. Inverse problems, on the other hand, involve estimation of inputs (commonly known as parameters) from noisy observations of a particular physical model (data). This low-dimensionality of the map causes the estimation of the parameters to be unstable in the presence of noise, which may be present in the system due to the observation process and/or model uncertainty. As a result, the problem is termed to be \textit{ill-posed} due to the violation of one of the three conditions for well-posedness postulated by Hadamard \cite{hadamard1923lectures}. This implies that despite the high-dimensional nature of the data, it does not provide sufficient information to compute a unique solution for the parameter. A computational framework capable of solving such inverse problems, thus, became an important requirement.

This requirement was addressed by \texttt{hIPPYlib}, an inverse problem library that was capable of solving ill-posed large-scale deterministic and Bayesian inverse problems \cite{villa2018hippylib}. \texttt{hIPPYlib} poses the learning-from-data problem as an inverse problem governed by the forward PDE problem. It exploited the low-dimensionality of the parameter-to-observable map to estimate the components of the model at a cost that is measured in terms of the number of forward model solutions. \texttt{hIPPYlib} discretizes the forward map (which is one of the three components of an inverse problem, as discussed in Section \ref{chapter: inverse-problems}) by using the functionality of the \texttt{FEniCS} library---a finite element library for partial differential equations (PDEs) \cite{alnaes2015fenics}. Since the data structures used in the FEniCS library are wrappers on the PETSc library's data structures, \texttt{hIPPYlib} uses PETSC \cite{balay2001petsc} for its linear solvers and algebra operations. The \texttt{FEniCS} library contains different components with multiple layers of abstraction for ease of development and usage. However, given the mathematically complex nature of finite element problems, the consistent development of the FEniCS library and subsequently, that of \texttt{hIPPYlib}, requires individuals highly skilled in programming and FEM concepts.

Similar to the FEniCS project's DOLFIN library \cite{alnaes2015fenics, logg2010dolfin}, Firedrake \cite{rathgeber2016firedrake} is a library that provides automated solutions of partial differential equations (PDEs) using the finite element method (FEM). Firedrake managed to address the abovementioned problems by introducing a new layer of abstraction named PyOP2 \cite{rathgeber2012pyop2}, while maintaining compatibility with FEniCS through the Unified Form Language (UFL) \cite{alnaes2014unified}. The FEniCS Project developed UFL \cite{alnaes2014unified} to express PDEs in a high-level mathematical language and seamlessly integrated it with their DOLFIN library. Well-defined domain-specific languages (DSLs) allow mathematicians to express their problem unambiguously, and Firedrake allows users to express finite element equations in the same syntax as that used in DOLFIN \cite{logg2010dolfin}. UFL is a symbolic language with well-defined finite element semantics, and its integration with Firedrake ensures that users of FEniCS can also use Firedrake with ease.  

Thus, the need for an inverse problem library built on a modularized FEM solver like Firedrake led to the conception of \texttt{hIPPYfire}. This study presents the structure and implementation of \texttt{hIPPYfire}---an inverse problem library modelled similar to \texttt{hIPPYlib}, but built on Firedrake. The algorithms implemented in \texttt{hIPPYfire} are identical to those implemented in \texttt{hIPPYlib}. However, there are minor differences in the utilities and linear algebra functions due to the currently limited functionality of the Firedrake library---all of which have been elaborated and expanded upon in the following sections of this report.

Section \ref{chapter: inverse-problems} provides a brief introduction to the theory behind inverse problems. The advantages of the Firedrake library over FEniCS are explained with some technical context in Section \ref{chapter: software}. Emphasis is also placed on the shortcomings of the Firedrake library and the development of custom linear algebra methods to address them. The structure of \texttt{hIPPYfire} is also discussed in Section \ref{chapter: software}. The \texttt{hIPPYfire} library is validated in Section \ref{chapter:sample-problem} by creating a test case involving a Bayesian inverse problem. This section is followed by the conclusion (Section \ref{chapter:conclusion}), which discusses the development roadmap for \texttt{hIPPYfire}.